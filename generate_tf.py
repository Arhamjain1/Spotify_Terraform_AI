# # generate_tf.py
# import json
# import sys
# from textwrap import dedent
# import re

# def url_to_uri(url):
#     """Convert Spotify track URL → Spotify URI."""
#     if not url:
#         return None
#     m = re.search(r"/track/([A-Za-z0-9]+)", url)
#     if not m:
#         return None
#     return f"spotify:track:{m.group(1)}"

# def sanitize_name(i, title, artist):
#     """Sanitize Terraform resource name safely."""
#     raw = f"t{i}_{title}_{artist}".lower()

#     # Replace spaces with underscores
#     raw = raw.replace(" ", "_")

#     # Remove everything NOT allowed in Terraform names
#     raw = re.sub(r"[^a-z0-9_-]", "", raw)

#     # Collapse repeated underscores
#     raw = re.sub(r"_+", "_", raw)

#     return raw[:60]   # Keep name reasonable length

# def generate_tf(tracks, out_file="tracks.tf"):
#     """Generate tracks.tf with locals block instead of individual resources."""
#     track_uris = []
#     track_comments = []
    
#     idx = 0
#     for t in tracks:
#         uri = t.get("uri") or url_to_uri(t.get("spotify_url"))
#         if not uri:
#             print(f"Skipping — No URI for: {t.get('input_title')}")
#             continue

#         title = t.get("matched_title", "Unknown")
#         artist = t.get("matched_artist", "Unknown")
        
#         # Extract just the track ID (base62) from spotify:track:XXX
#         track_id = uri.replace("spotify:track:", "")
        
#         track_uris.append(f'    "{track_id}",')
#         track_comments.append(f'    # {title} - {artist}')
#         idx += 1

#     with open(out_file, "w", encoding="utf-8") as f:
#         f.write("// AUTO-GENERATED by generate_tf.py — DO NOT EDIT\n\n")
#         f.write("locals {\n")
#         f.write("  playlist_tracks = [\n")
        
#         for uri, comment in zip(track_uris, track_comments):
#             f.write(f"{comment}\n")
#             f.write(f"{uri}\n")
        
#         f.write("  ]\n")
#         f.write("}\n")

#     print(f"\nWrote {out_file} with {idx} tracks in locals block.")

# if __name__ == "__main__":
#     infile = sys.argv[1] if len(sys.argv) > 1 else "spotify_results.json"
#     tracks = json.load(open(infile, encoding="utf-8"))

#     print("\n=== DEBUG: Loaded Tracks ===")
#     print(json.dumps(tracks, indent=2))
#     print("============================\n")

#     generate_tf(tracks)

# generate_tf.py

# generate_tf.py
import json
import sys
from textwrap import dedent
import re
import os

def url_to_uri(url):
    """Convert Spotify track URL → Spotify URI."""
    if not url:
        return None
    m = re.search(r"/track/([A-Za-z0-9]+)", url)
    if not m:
        return None
    return f"spotify:track:{m.group(1)}"

def sanitize_name(i, title, artist):
    """Sanitize Terraform resource name safely."""
    raw = f"t{i}_{title}_{artist}".lower()

    # Replace spaces with underscores
    raw = raw.replace(" ", "_")

    # Remove everything NOT allowed in Terraform names
    raw = re.sub(r"[^a-z0-9_-]", "", raw)

    # Collapse repeated underscores
    raw = re.sub(r"_+", "_", raw)

    return raw[:60]   # Keep name reasonable length

def extract_existing_tracks(out_file="tracks.tf"):
    """Extract existing track IDs from tracks.tf if it exists."""
    existing_tracks = {}
    
    if not os.path.exists(out_file):
        return existing_tracks
    
    try:
        with open(out_file, "r", encoding="utf-8") as f:
            content = f.read()
        
        # Extract track IDs from the locals block
        # Match pattern: "track_id", (with optional comment)
        matches = re.findall(r'"([a-zA-Z0-9]+)"(?:\s*,)?', content)
        for track_id in matches:
            if len(track_id) > 10:  # Spotify track IDs are base62, typically 22 chars
                existing_tracks[track_id] = True
    except Exception as e:
        print(f"Warning: Could not read existing tracks: {e}")
    
    return existing_tracks

def generate_tf(tracks, out_file="tracks.tf", retain_old=True):
    """Generate tracks.tf with locals block, optionally merging with existing tracks."""
    
    track_uris = []
    track_comments = []
    
    idx = 0
    new_count = 0
    
    for t in tracks:
        uri = t.get("uri") or url_to_uri(t.get("spotify_url"))
        if not uri:
            print(f"Skipping — No URI for: {t.get('input_title')}")
            continue

        title = t.get("matched_title", "Unknown")
        artist = t.get("matched_artist", "Unknown")
        
        # Extract just the track ID (base62) from spotify:track:XXX
        track_id = uri.replace("spotify:track:", "")
        
        track_uris.append(f'    "{track_id}",')
        track_comments.append(f'    # {title} - {artist}')
        new_count += 1
        idx += 1

    # Add existing tracks if retention is enabled
    if retain_old:
        existing_tracks = extract_existing_tracks(out_file)
        print(f"Found {len(existing_tracks)} existing tracks in {out_file}")
        
        added_ids = set(uri.strip().strip('"').rstrip(',') for uri in track_uris)
        for existing_id in existing_tracks:
            if existing_id not in added_ids:
                track_uris.append(f'    "{existing_id}",')
                track_comments.append(f'    # (retained from previous run)')
    else:
        print(f"Skipping old tracks (retention disabled)")

    with open(out_file, "w", encoding="utf-8") as f:
        f.write("// AUTO-GENERATED by generate_tf.py — DO NOT EDIT\n\n")
        f.write("locals {\n")
        f.write("  playlist_tracks = [\n")
        
        for uri, comment in zip(track_uris, track_comments):
            f.write(f"{comment}\n")
            f.write(f"{uri}\n")
        
        f.write("  ]\n")
        f.write("}\n")

    total_tracks = len(track_uris)
    retained = total_tracks - new_count
    print(f"\nWrote {out_file}:")
    print(f"  - {new_count} new tracks")
    print(f"  - {retained} retained tracks")
    print(f"  - {total_tracks} total tracks")

if __name__ == "__main__":
    infile = sys.argv[1] if len(sys.argv) > 1 else "spotify_results.json"
    
    data = json.load(open(infile, encoding="utf-8"))
    
    # Handle different data formats
    if isinstance(data, dict):
        # New format: {"retain_old_tracks": bool, "songs": [...]} or {"retain_old_songs": bool, "songs": [...]}
        if "retain_old_tracks" in data or "retain_old_songs" in data:
            retain_old = data.get("retain_old_tracks", data.get("retain_old_songs", True))
            tracks = data.get("songs", [])
        else:
            # Old format: just a dict with songs
            retain_old = True
            tracks = data
    else:
        # Fallback: array of tracks
        retain_old = True
        tracks = data

    # Ensure tracks is a list
    if not isinstance(tracks, list):
        raise ValueError(f"Expected tracks to be a list, got {type(tracks)}")

    print("\n=== DEBUG: Loaded Tracks ===")
    if tracks:
        print(json.dumps(tracks[:2], indent=2))  # Show first 2 tracks only
        print(f"... ({len(tracks)} total tracks)")
    print(f"Retention flag: {retain_old}")
    print("============================\n")

    generate_tf(tracks, retain_old=retain_old)